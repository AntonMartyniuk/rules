<?php

/**
 * Defines if an execution log should be displayed
 */
define('rules_ENABLE_DEBUG', FALSE);

/**
 * Implementation of hook_init()
 */
function rules_init() {
	// Also load available integration for all activated modules
	$path = drupal_get_path('module', 'rules') . '/modules';
	$files = drupal_system_listing('rules\..*\.inc$', $path, 'name', 0);

	foreach ($files as $file) {
	  // The filename format is very specific. It must be rules.MODULENAME.inc
	  $module = substr_replace($file->name, '', 0, 6);
	  if (module_exists($module)) {
	    require_once("./$file->filename");
	  }
	}
}

/**
 * Returns info about all defined events
 */
function rules_get_events($key = 'all') {
  return rules_gather_data('rules_event_info', $key);
}

/**
 * Returns info about all defined actions
 */
function rules_get_actions($key = 'all') {
  //TODO: integrate d6 actions
  return rules_gather_data('rules_action_info', $key);
}

/**
 * Returns info about all defined conditions
 */
function rules_get_conditions($key = 'all') {
  return rules_gather_data('rules_condition_info', $key);
}

/**
 * Returns info about all defined items
 */
function rules_get_items($key = 'all') {
  return rules_gather_data('rules_item_info', $key);
}


/**
 * Returns all defined item defaults
 * $items Which defaults to return, e.g. 'rules', 'rule_sets' or 'states'
 */
function rules_get_item_defaults($items = 'rules') {
  _rules_include_rules_defaults();
  return rules_gather_data('rules_defaults', 'all', FALSE);
}

/**
 * Gathers module definitions for the given name
 * Used for collecting events, rules, actions and condtions from other modules
 *
 * @param $name The type of the data item to collect. This is also the name of the invoked hook.
 * @param $key Whether to retrieve all definitions or only the one with the given key
 * @param $alter Whether drupal_alter() should be invoked for this data
 * @param $reset If the static cache should be reseted. Note that if set to true, nothing will be
 *               returned.
 */
function rules_gather_data($name, $key = 'all', $alter = TRUE, $reset = FALSE) {
  static $data = array();

  if ($reset) {
    $data = array();
    return;
  }
  if (!isset($data[$name])) {
    $data[$name] = module_invoke_all($name);
    if ($alter) {
      drupal_alter($name, $data['name']);
    }
  }
  return $key != 'all' && isset($data[$name][$key]) ? $data[$name][$key] : $data[$name];
}

/**
 * Extracts the property with the given name while keeping the keys
 * 
 * @param $key The name of the property to extract
 * @param $elements An array of elements
 * @return An array of extracted properties.
 */
function rules_extract_property($key, $elements) {
  $data = array();

  foreach ($elements as $name => $info) {
    $data[$name] = $info[$key];
  }
  return $data;
}

/**
 * Some element defaults not being applied automatically
 */
function rules_element_defaults_event_info() {
  return array('module' => '', 'arguments' => array(), 'new arguments' => array(), 'redirect' => FALSE);
}
function rules_element_defaults_action_info() {
  return array('arguments' => array(), 'fixed' => FALSE);
}
function rules_element_defaults_condition_info() {
  return array('arguments' => array(), 'fixed' => FALSE);
}



/**
 * Returns all active configurations for the event $event_name
 *
 * @param $event_name The event name, for which the configurations should be returned.
 * @param $reset May be set to true to clear the cache.
 * @return Returns the configured configurations for this event
 */
function rules_event_get_configurations($event_name = NULL, $reset = FALSE) {
  //We prevent a lot of queries by storing all event names with activated configurations with variable_set
  static $configs;

  if (!isset($configs) || $reset) {
    //initialize
    $configs = variable_get('rules_configurations', array());
  }

  if (isset($event_name) && !isset($configs[$event_name])) {
    if (!$reset && $cache = cache_get('cfg_'. $event_name, 'cache_rules')) {
      $configs[$event_name] = unserialize($cache->data);
    }
    else {
      //cache miss, so refresh the cache for all events
      $configs = rules_get_configurations_by_event();
      $variable_cache = array();
      foreach (rules_get_events('labels') as $name => $label) {
        $configs += array($name => array());
        //remove deactivated configurations
        $configs[$name] = array_filter($configs[$name], '_rules_configuration_is_active');
        //and write the cache
        if (count($configs[$name])) {
          cache_set('cfg_'. $name, 'cache_rules', serialize($configs[$name]));
        }
        else {
          //write in the variable cache, that there are no configs for this event
          $variable_cache[$name] = array();
        }
      }
      variable_set('rules_configurations', $variable_cache);
    }
  }
  return isset($event_name) ? $configs[$event_name] : NULL;
}

/**
 * Helper for array_filter()
 */
function _rules_configuration_is_active($configuration) {
  _rules_element_defaults($configuration);
  return $configuration['#active'];
}

/**
 * Gathers the configurations and returns the configurations for the given event
 * This bypasses any database cache!
 *
 * @param $event_name The event name, for which the configurations should be returned.
 *        Leave it empty, to get all configurations sorted by event.
 * @param $reset May be set to true to clear the static cache.
 */
function rules_get_configurations_by_event($event_name = NULL, $reset = FALSE) {
  static $configurations;

  if ($reset) {
    $configurations = NULL;
    return;
  }

  if (!isset($configurations)) {
    $configurations = array();
    foreach (rules_get_configurations() as $key => $configuration) {
      $configurations += array($configuration['#event'] => array());
      $configurations[$configuration['#event']][$key] = $configuration;
    }
  }
  return isset($event_name) && isset($configurations[$event_name]) ? $configurations[$event_name] : $configurations;
}

/**
 * Clears the workflow-ng cache
 * @param $immediate If FALSE, the static cache will be kept until the next page load.
 *    Might be dangerous, so only use if you know what you are doing.
 */
function rules_clear_cache($immediate = TRUE) {
  cache_clear_all('cfg_', 'cache_rules', TRUE);
  variable_del('rules_configurations');
  if ($immediate) {
    rules_event_get_configurations(NULL, TRUE);
    rules_get_configurations_by_event(NULL, TRUE);
    rules_gather_data('', FALSE, 'all', NULL, TRUE);
  }
}

/**
 * Invokes configured actions/conditions for the given event
 * @param $event_name As first param pass the event name
 * @params $args Pass further arguments as defined in hook_event_info() for this event.
 */
function rules_invoke_event() {
  $args = func_get_args();
  $event_name = array_shift($args);
  if ($event = rules_get_events('all', $event_name)) {
    //apply the event element defaults
    _rules_element_defaults($event);

    //log, if debugging is activated
    $log = rules_ENABLE_DEBUG ? array() : FALSE;
    rules_write_log($log, t('Event @label has been invoked.', array('@label' => $event['#label'])));

    //get the active configurations
    if ($configurations = rules_event_get_configurations($event_name)) {
      //get the processed arguments
      $arguments = _rules_process_arguments($event, $args);
      //evaluate the configurations
      rules_evaluate_configurations($configurations, $arguments, $log);
    }

    rules_show_log($log);
  }
}

/**
 * Evaluates the configurations by using rules_evaluate_elements()
 * Afterwards it cares for saving the modified arguments.
 *
 * @param $configurations The configurations to process
 * @param $arguments An array of arguments in format as returned from _rules_process_arguments()
 * @param $log An array of log entries. Set it to FALSE to disable logging, otherwise initialize it with array()
 */
function rules_evaluate_configurations($configurations, &$arguments, &$log) {
  //First apply the configurations defaults
  _rules_element_defaults($elements);

  //then start processing
  rules_evaluate_elements($configurations, $arguments, $log);

  //save all the changed arguments..
  foreach ($arguments['save'] as $argument_name) {
    rules_save_argument($arguments['info'][$argument_name], $argument_name, $arguments['data'][$argument_name], $log);
  }
  //we have finished processing, so reset the recursion prevention log..
  rules_evaluated_configurations(FALSE, TRUE);
}


/**
 * Evaluates the elements in a recursive way
 * The elements are a tree of configurations, conditions, actions and logical operations (AND, OR,..)
 *
 * Each element is executed by using rules_execute_element().
 *
 * Elements can use '#execute' to set their execution handler, which can be used to
 * to customize the evaluation of the children. E.g. the element 'OR' does this and
 * evaluates to TRUE if at least one of its children evaluate to TRUE.
 *
 * @param $elements An array of elements to evaluate
 * @param $arguments An array of arguments in format as returned from _rules_process_arguments()
 * @param $log An array of log entries. Set it to FALSE to disable logging, otherwise initialize it with array()
 */
function rules_evaluate_elements(&$elements, &$arguments, &$log) {
  $result = FALSE;

  //Execute the current element if not yet executed
  if (!isset($elements['#_executed'])) {
    $elements['#_executed'] = TRUE;
    $result = rules_execute_element($elements, $arguments, $log);
  }

  // we default to evaluate like an AND, which means we stop as soon as one element evaluates to FALSE
  // so if the element hasn't evaluated the children, start now
  if ((!isset($elements['#_evaluated']) || $elements['#_evaluated'] == FALSE)) {
    $elements['#_evaluated'] = TRUE;
    $result = rules_execute_and($elements, $arguments, $log);
  }
  return $result;
}

/**
 * Sorts the children of the elements
 */
function _rules_sort_children(&$element) {
  if (!isset($element['#_sorted'])) {
    $element['#_sorted'] = TRUE;
    uasort($element, "_rules_element_sort");
  }
}

/**
 * Callback function for uasort()
 */
function _rules_element_sort($a, $b) {
  if (!is_array($a) || ($b['#type'] == 'action' && $a['#type'] != 'action')) {
    return -1; //actions sink always down, element properties up
  }
  if (!is_array($b) || ($a['#type'] == 'action' && $b['#type'] != 'action')) {
    return 1; //actions sink always down, element properties up
  }
  $a += array('#weight' => 0, '#id' => 1000);
  $b += array('#weight' => 0, '#id' => 1000);
  if ($a['#weight'] == $b['#weight']) {
    return ($a['#id'] < $b['#id']) ? -1 : 1;
  }
  return ($a['#weight'] < $b['#weight']) ? -1 : 1;
}

/**
 * Makes sure the element defaults are applied
 */
function _rules_element_defaults(&$element) {
  if (!isset($element['#_defaults_applied'])) {
    if ((!empty($element['#type'])) && ($info = _element_info($element['#type']))) {
      // Overlay $info onto $element, retaining preexisting keys in $element.
      $element += $info;
    }
    $element['#_defaults_applied'] = TRUE;
  }
}

/**
 * Executes the element by invoking the element type's execution handler
 *
 * @param $elements An array of elements to process
 * @param $arguments An array of arguments in format as returned from _rules_process_arguments()
 * @param $log An array of log entries. Set it to FALSE to disable logging
 * @return The execution result, or FALSE if there is no valid execution handler.
 */
function rules_execute_element(&$element, &$arguments, &$log) {
  if (isset($element['#type']) && isset($element['#execute']) && function_exists($element['#execute'])) {
    //default to not process the children, if there is an execution handler
    $element['#_evaluated'] = TRUE;
    $result = $element['#execute']($element, $arguments, $log);
    return isset($element['#negate']) && $element['#negate'] == TRUE ? !$result : $result;
  }
  return FALSE;
}

/**
 * Execution handler for configurations
 * We want each configuration to be evaluated, so let the following configurations
 * be processed by returning always TRUE.
 *
 */
function rules_execute_configuration(&$element, &$arguments, &$log) {
  if ($element['#active'] && ($element['#recursion'] == TRUE || !in_array($element['#name'], rules_evaluated_configurations()))) {

    rules_write_log($log, t('Executing the configuration @name on event @event', array('@name' => $element['#label'], '@event' => rules_get_events('labels', $element['#event']))));
    //remember that we are processing this configuration to prevent recursion
    rules_evaluated_configurations($element['#name']);
    //let the the default evaluation (AND) apply to the configuration
    rules_execute_and($element, $arguments, $log);
  }
  //return true, so that the next configurations are evaluated too
  return TRUE;
}

/**
 * Execution handler for the OR element
 * Evaluates to TRUE if at least one children evaluate to TRUE..
 */
function rules_execute_or(&$elements, &$arguments, &$log) {
  //first sort the children then process them
  _rules_sort_children($elements);

  foreach (element_children($elements) as $key) {
    _rules_element_defaults($elements[$key]);
    //propagate the event name down the tree, then recurse
    $elements[$key] += array('#event' => $elements['#event']);
    $result = rules_evaluate_elements($elements[$key], $arguments, $log);
    if ($result == TRUE) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Execution handler for the AND element
 * Evaluates to TRUE if all children evaluate to TRUE..
 */
function rules_execute_and(&$elements, &$arguments, &$log) {
  //first sort the children then process them
  _rules_sort_children($elements);
  //process them
  foreach (element_children($elements) as $key) {
    _rules_element_defaults($elements[$key]);
     //propagate the event name down the tree, then recurse
    $elements[$key] += array('#event' => $elements['#event']);
    $result = rules_evaluate_elements($elements[$key], $arguments, $log);
    if ($result === FALSE) {
      //stop processing the children
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Execution handler for actions
 *
 * @param $element The action's configuration element
 * @param $arguments An array of arguments in format as returned from _rules_process_arguments()
 * @param $log An array of log entries. Set it to FALSE to disable logging
 * @return TRUE to let rules proceed wit executing actions, only FALSE if $result['#halt'] is set.
 */
function rules_execute_action($element, &$arguments, &$log) {
  if (isset($element['#name']) && function_exists($element['#name'])) {

    $exec_args = rules_get_execution_arguments($element, $arguments, $log);
    if ($exec_args !== FALSE) {
      $result = call_user_func_array($element['#name'], $exec_args);

      //Add newly added arguments by the action
      if (isset($result['#new arguments']) && $result['#new arguments']) {
        rules_add_new_arguments($element, $result['#new arguments'], $arguments, $log);
      }
      //An action may return altered arguments, which will be saved automatically
      if (isset($result) && is_array($result)) {
        $reverse_map = array_flip($element['#argument map']);

        foreach (element_children($result) as $argument_name) {
          $event_arg_name = isset($reverse_map[$argument_name]) ? $reverse_map[$argument_name] : $argument_name;
          rules_set_argument_to_save($event_arg_name, $result[$argument_name], $arguments);
        }
      }
      rules_write_log($log, t('Action execution: @name', array('@name' => rules_get_element_label($element))));

      //this allows actions to act as conditions too
      if (isset($result['#halt']) && $result['#halt']) {
        rules_write_log($log, t('Action @name evaluated to @bool.', array('@name' => rules_get_element_label($element), '@bool' => 'FALSE')));
        return FALSE;
      }
    }
    return TRUE;
  }
  rules_missing_module($element);
}

/**
 * Execution handler for conditions
 * Note: An condition may not alter arguments
 *
 * @param $element The condition's configuration element
 * @param $arguments An array of arguments in format as returned from _rules_process_arguments()
 * @param $log An array of log entries. Set it to FALSE to disable logging
 * @return The execution result of the condition, or if it is no valid condition FALSE.
 */
function rules_execute_condition($element, &$arguments, &$log) {
  if (isset($element['#name']) && function_exists($element['#name'])) {

    $exec_args = rules_get_execution_arguments($element, $arguments, $log);
    if ($exec_args !== FALSE) {
      $result = call_user_func_array($element['#name'], $exec_args);

      $element += rules_get_element_info($element);
      rules_write_log($log, t('Condition @name evaluated to @bool.', array('@name' => rules_get_element_label($element), '@bool' => $result ? 'TRUE' : 'FALSE')));
      return $result;
    }
    return FALSE;
  }
  rules_missing_module($element);
  return FALSE;
}

/**
 * Writes the message into the log
 */
function rules_write_log(&$log, $message) {
  if ($log !== FALSE && is_array($log)) {
    list($usec, $sec) = explode(" ", microtime());
    $log[] = array('time' => array('sec' => $sec, 'usec' => $usec), 'msg' => $message);
  }
}

/**
 * Returns the execution arguments needed by the given element
 * It applies the #argument map and gets all needed arguments.
 * 
 * @param $element The configured element, which is to be executed
 * @param $arguments An array of arguments in format as returned from _rules_process_arguments()
 * @param $log An array of log entries. Set it to FALSE to disable logging
 * @return If not all execution arguments are available, it returns FALSE
 */
function rules_get_execution_arguments(&$element, &$arguments, &$log) {
  $exec_args = array();
  $args_error = FALSE;

  $element_info = rules_get_element_info($element);
  //initialize unset arguments in the argument map with pairs: name => name
  //this allows ommitting such obvious mappings
  $reverse_map = array_flip($element['#argument map']) + drupal_map_assoc(array_keys($element_info['#arguments']));
  $element['#argument map'] = array_flip($reverse_map);

  //get the right execution arguments by applying the argument map of this element
  foreach ($element_info['#arguments'] as $argument_name => $info) {
    $event_arg_name = $reverse_map[$argument_name];
    $exec_args[$argument_name] = rules_element_get_argument($arguments, $event_arg_name, $log);
    $args_error = !isset($exec_args[$argument_name]) || $args_error;
  }

  //we always append some other useful variables
  $settings = isset($element['#settings']) ? $element['#settings'] : array();
  $settings += array('#argument map' => $element['#argument map']);
  $exec_args[] = $settings;
  $exec_args[] = &$arguments;
  $exec_args[] = &$log;
  return $args_error ? FALSE : $exec_args;
}



/**
 * Implementation of hook_elements()
 * Defines default values for all available properties of rules's element types
 *
 * Note that the #process handlers are only used by the form API, but not by workflow-ng itself.
 */
function rules_elements() {
  $types = array();
  $types['configuration'] = array('#name' => '', '#module' => '', '#event' => '', '#recursion' => FALSE, '#fixed' => FALSE, '#active' => TRUE, '#altered' => FALSE, '#execute' => 'rules_execute_configuration', '#process' => array('rules_ui_prepare_configuration' => array()));
  $types['condition'] = array('#name' => '', '#info' => TRUE, '#argument map' => array(), '#negate' => FALSE, '#settings' => array(), '#execute' => 'rules_execute_condition', '#suffix' => '<br clear="all" />');
  $types['action'] = array('#name' => '', '#info' => TRUE, '#argument map' => array(), '#settings' => array(), '#execute' => 'rules_execute_action', '#suffix' => '<br clear="all" />');
  $types['OR'] = array('#execute' => 'rules_execute_or', '#logical_op' => TRUE, '#negate' => FALSE, '#theme' => 'rules_operation', '#label' => t('OR'));
  $types['AND'] = array('#execute' => 'rules_execute_and', '#logical_op' => TRUE, '#negate' => FALSE, '#theme' => 'rules_operation', '#label' => t('AND'));
  return $types;
}

/**
 * Processes the arguments of an event to an array in the style as it is required
 * for rules_evaluate_elements().
 *
 * The returned array format is like:
 * array(
 *   'info' => array('arg1_name' => array(..),.. )  //the argument definitions of all available arguments, as it's specified with the #argument property of an event
 *   'save' => array('arg1_name', ..), //an array of arguments that have to be saved
 *   'data' => array('arg1_name' => $arg1, 'arg2_name' => $arg2, ..), //an array of loaded arguments
 * );
 *
 * Note that the order of the arguments will be kept, as it might be important for passing
 * the arguments to further argument loading handlers.
 *
 * @param $event The event info from the currently processed event
 * @param $args The argument data passed with the event invocation
 */
function _rules_process_arguments($event, $args) {
  $argument_names = array_keys($event['#arguments']);
  $arguments = array('save' => array(), 'data' => array(), 'info' => $event['#arguments']);

  if (isset($args[0]) && count($args) == 1 && is_array($args[0]) && count($args[0]) > 0 && array_diff(array_keys($args[0]), $argument_names) === array()) {
    //the caller passed an array of arguments, so let's use that
    $arguments['data'] = $args[0];
  }
  else {
    foreach ($args as $index => $argument) {
      if (isset($argument_names[$index])) {
        $arguments['data'][$argument_names[$index]] = $argument;
      }
    }
  }
  return $arguments;
}

/**
 * Returns the needed argument, which is given by the argument name. This function will take care of loading
 * further needed arguments, as necessary.
 *
 * @param $arguments The existing arguments in the format as returned from _rules_process_arguments()
 * @param $argument_name The arguments's machine readable name
 * @param $log An array of log entries. Set it to FALSE to disable logging
 */
function rules_element_get_argument(&$arguments, $argument_name, &$log) {

  if (!isset($arguments['data'][$argument_name])) {
    if ($arguments['info'][$argument_name]['#handler'] && function_exists($arguments['info'][$argument_name]['#handler'])) {
      //call the handler to get the runtime data
      $arguments['data'][$argument_name] = call_user_func_array($arguments['info'][$argument_name]['#handler'], $arguments['data']);
      rules_write_log($log, t('Successfully loaded argument @arg', array('@arg' => $arguments['info'][$argument_name]['#label'])));
    }
  }
  return $arguments['data'][$argument_name];
}

/**
 * Adds the new arguments to $arguments
 */
function rules_add_new_arguments($element, $new_arguments, &$arguments, &$log) {
  foreach ($element['#new arguments'] as $event_name => $argument_info) {
    $map[$argument_info['#default_name']] = $event_name;
  }
  foreach ($new_arguments as $name => $data) {
    $event_name = $map[$name];
    $arguments['data'][$event_name] = &$new_arguments[$name];
    $arguments['info'][$event_name] = $element['#new arguments'][$event_name];
    rules_write_log($log, t('Successfully added the new argument @arg', array('@arg' => $arguments['info'][$event_name]['#label'])));
  }
}

/**
 * Gets the element info of an element (actions, conditions,..)
 * Note that the element defaults will be applied before, if not yet done.
 */
function rules_get_element_info(&$element) {
  _rules_element_defaults($element);
  if ($element['#info'] && $element['#name']) {
    $info = rules_gather_data($element['#type']. '_info', FALSE, 'all', $element['#name']);
    if (isset($info)) {
      //apply the element info defaults
      $info['#type'] = $element['#type']. '_info';
      _rules_element_defaults($info);

      if (array_key_exists('#description', $element) && isset($info['#description'])) {
        unset($element['#description']); //Make sure the description is applied
      }
      return $info;
    }
    rules_missing_module($element);
    return array();
  }
  return array();
}

/**
 * Gets the element's label
 */
function rules_get_element_label($element) {
  if (!isset($element['#label'])) {
    //apply the default from hook_element_type_info
    $element += rules_get_element_info($element);
  }
  return $element['#label'];
}

/**
 * A simple helping function, which eases the creation of configurations
 * Example use case:  $configuration['or'] = rules_configure('OR', $condition1, conditions2);
 *
 * @param $op One supported operation like 'AND', 'OR'. If ommitted the passed elements
 *   will just be added to the first one.
 * @param $elements The elements to configure.
 */
function rules_configure() {
  $args = func_get_args();
  $op = array_shift($args);

  if (!is_string($op) && is_array($op)) {
    //just add the elements to the first element
    return array_merge($op, $args);
  }
  $op = strtoupper($op);

  $element = rules_use_element($op);
  $element += $args;
  return $element;
}

/**
 * Configures a condition for using in a configuration
 *
 * @param $name The name of condition to create, as specified at hook_condition_info()
 * @param $params An optional array of properties to add, e.g. #argument_map
 */
function rules_use_condition($name, $params = array()) {
  $params += array('#name' => $name);
  return rules_use_element('condition', $params);
}

/**
 * Configures an action for using in a configuration
 *
 * @param $name The name of action to create, as specified at hook_action_info()
 * @param $params An optional array of properties to add, e.g. #argument_map
 */
function rules_use_action($name, $params = array()) {
  $params += array('#name' => $name);
  return rules_use_element('action', $params);
}

/**
 * Configures an element of type $type with the further properties $params for using in a configuration
 */
function rules_use_element($type, $params = array()) {
  $element = array('#type' => $type);
  $element += $params;
  return $element;
}

/**
 * Shows the log if it's active
 */
function rules_show_log($log) {
  if (is_array($log) && count($log)) {
    $start = $log[0]['time'];
    $output = array();
    foreach ($log as $data) {
      $diff = ($data['time']['sec'] - $start['sec'])*1000000 + $data['time']['usec'] - $start['usec'];
      $formatted_diff = round($diff * 1000, 3). ' ms';
      $output[] = $formatted_diff . ' '. $data['msg'];
    }
    drupal_set_message(implode('<br />', $output));
  }
}

/**
 * Remembers the currently evaluated configurations. With this information, recursion is prevented
 *
 * @param $add_name If set to FALSE, all already processed configurations will be returned
 *   Otherwise, the passed configuration name will be stored for further lookups.
 * @param $reset Clears the saved configurations if set.
 */
function rules_evaluated_configurations($add_name = FALSE, $reset = FALSE) {
  static $memory = array();

  if ($reset) {
    $memory = array();
  }
  if ($add_name !== FALSE) {
    $memory[$add_name] = $add_name;
  }
  return $memory;
}


/**
 * Gets all configured items, regardless if defined by the admin
 * or by a module
 * 
 * @param $items Which items to get, e.g. 'rules' or 'rule_sets'
 * @return An array of configured items, where structure of the item configuration
 *   depends on the item
 */
function rules_get_configuration($items = 'rules') {
  $configurations = array();
  $info = rules_get_items($items);
  $result = db_query("SELECT * FROM {". $info['db_table']. "}");

  while ($row = db_fetch_object($result)) {
    $configurations[$row->name] = unserialize($row->data);
  }
  $configurations += rules_get_item_defaults($items);
  return $configurations;
}


/**
 * Used to inform the rules engine about added items,
 * so it can create the db table if necessary
 */
function rules_enable_items($items) {
  $info = rules_get_items($items);

  if (!db_table_exists($info['db_table'])) {
    $schema = drupal_get_schema($info['db_table'], TRUE);
    $ret = array();
    db_create_table($ret, $info['db_table'], $schema);
  }
}

/**
 * Implementation of hook_rules_item_info
 */
function rules_rules_item_info() {
  return array(
    'rules' => array(
      'label' => t('Rules'),
      'db_table' => 'rules_rules',
    ),
    'rule_sets' => array(
      'label' => t('Rule Sets'),
      'db_table' => 'rule_sets',
    ),
  );
}


/**
 * Shows an error message, that a module is missing.
 *
 * @param $element The element, for which the module is missing
 * @param $configuration_name The name of the configuration of the element
 */
function rules_missing_module($element, $configuration_name = NULL) {
  static $history = array();

  if (isset($history[$element['#name']])) {
    //error already generated
    return;
  }
  $history[$element['#name']] = TRUE;

  if (isset($element['#label']) && $element['#label']) {
    $msg = t('Unable to find %type of name %name with the label %label. Perhaps the according modules has been deactivated.', array('%type' => $element['#type'], '%name' => $element['#name'], '%label' => $element['#label']));
  }
  else {
    $msg = t('Unable to find %type of name %name. Perhaps the according modules has been deactivated.', array('%type' => $element['#type'], '%name' => $element['#name']));
  }
  rules_handle_error_msg($msg, $configuration_name);
}

/**
 * Handles a error message. If the user has permission to administer workflow,
 * show him the error. Otherwise just log it.
 */
function rules_handle_error_msg($message, $configuration_name = NULL) {
  if (user_access('administer workflow-ng')) {
    drupal_set_message($message, 'error');
  }
  $link = (module_exists('rules_ui') && isset($configuration_name)) ? l(t('Show configuration'), PATH .'/'. $configuration_name) : NULL;
  watchdog('workflow-ng', $message, WATCHDOG_ERROR, $link);
}

/**
 * Determines if the given entity type is supported by the given info
 * 
 * @param $entity_type The entity type to check
 * @param $info The information data containing the #entity property
 */
function rules_is_valid_entity($entity_type, $info) {
  if (is_array($info['#entity'])) {
    return in_array($entity_type, $info['#entity']);
  }
  if ($info['#entity'] == '*') {
    return TRUE;
  }
  return $info['#entity'] == $entity_type;
}

/**
 * Marks the given argument to be saved after configuration evaluation
 */
function rules_set_argument_to_save($argument_name, $value, &$arguments) {
  //update the arguments for all following elements mark them for being saved later
  if (isset($argument_name) && isset($arguments['data'][$argument_name])) {
    $arguments['data'][$argument_name] = $value;
    $arguments['save'][$argument_name] = $argument_name;
  }
}

/**
 * Saves a modified argument
 * @param $info The argument info as specified through hook_event_info()
 * @param $argument_name The name of the argument to save
 * @param $value The new value of the argument
 */
function rules_save_argument($info, $argument_name, $value, &$log) {
  if (isset($info['#saved']) && $info['#saved']) {
    //the argument is saved automatically, so we need to do nothing
    return;
  }
  $entity_info = rules_gather_data('entity_info', FALSE);
  if (isset($entity_info[$info['#entity']]['#save']) && function_exists($entity_info[$info['#entity']]['#save'])) {
    $entity_info[$info['#entity']]['#save']($value);
    rules_write_log($log, t('Updated entity @name of type @type.', array('@name' => $info['#label'], '@type' => $info['#entity'])));
  }
  else {
    rules_write_log($log, t('Entity @value has not been saved.', array('@value' => $info['#entity'])));
  }
}

/**
 * Implementation of hook_entity_info
 */
function rules_entity_info() {
  return array(
    'node' => array('#save' => 'rules_node_save'),
    'comment' => array('#save' => 'rules_comment_save')
  );
}

/**
 * Wrappers around drupal's saving functions
 */
function rules_node_save($node) {
  //make sure to not create a new revision when workflow-ng saves a node
  $node->revision = FALSE;
  node_save($node);
}

/**
 * Wrappers around drupal's saving functions
 */
function rules_comment_save($comment) {
  comment_save((array)$comment);
}

/**
 * Own version of array_intersect_key for php < 5.1
 */
if (!function_exists('array_intersect_key')) {
    function array_intersect_key()
    {
        $arrs = func_get_args();
        $result = array_shift($arrs);
        foreach ($arrs as $array) {
            foreach ($result as $key => $v) {
                if (!array_key_exists($key, $array)) {
                    unset($result[$key]);
                }
            }
        }
        return $result;
   }
}

/**
 * Implementation of hook_form_alter()
 * Clear workflow-ng's cache when a module is deactivated
 */
function rules_form_alter($form_id, $form) {
  if ($form_id == 'system_modules') {
    rules_clear_cache();
  }
}

/**
 * Include default configuration files
 */
function _rules_include_rules_defaults() {
  static $included;

  if (!isset($included)) {
    foreach (module_list() as $module) {
	    $module_path = drupal_get_path('module', $module);
	    if (file_exists("$module_path/$module.rules_defaults.inc")) {
	      require_once "./$module_path/$module.rule_defaults.inc";
	    }
	  }
    $included = TRUE;
  }
}
