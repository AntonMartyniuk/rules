<?php
// $Id$
/**
 * @file Rules engine module
 */

/**
 * Implementation of hook_init()
 */
function rules_init() {
	// Also load available integration for all activated modules
	$path = drupal_get_path('module', 'rules') . '/modules';
	$files = drupal_system_listing('rules\..*\.inc$', $path, 'name', 0);

	foreach ($files as $file) {
	  // The filename format is very specific. It must be rules.MODULENAME.inc
	  $module = substr_replace($file->name, '', 0, 6);
	  if (module_exists($module)) {
	    require_once("./$file->filename");
	  }
	}
	require_once drupal_get_path('module', 'rules') . '/rules.arguments.inc';
}

/**
 * Returns info about all defined events
 */
function rules_get_events($key = 'all') {
  return rules_gather_data('rules_event_info', $key);
}

/**
 * Returns info about all defined actions
 */
function rules_get_actions($key = 'all') {
  //TODO: integrate d6 actions
  return rules_gather_data('rules_action_info', $key);
}

/**
 * Returns info about all defined conditions
 */
function rules_get_conditions($key = 'all') {
  return rules_gather_data('rules_condition_info', $key);
}

/**
 * Returns info about all defined items
 */
function rules_get_items($key = 'all') {
  return rules_gather_data('rules_item_info', $key);
}

/**
 * Returns all defined item defaults
 * $items Which defaults to return, e.g. 'rules', 'rule_sets' or 'states'
 */
function rules_get_item_defaults($items = 'rules') {
  _rules_include_rules_defaults();
  $defaults = rules_gather_data('rules_defaults', 'all', FALSE);
  return isset($defaults[$items]) ? $defaults[$items] : array();
}

/**
 * Returns info about all rule sets, which includes events
 * 
 * @param $key If given, only the info about this rule set will be returned
 */
function rules_get_rule_sets($key = NULL) {
  $sets = rules_get_configuration('rule_sets');
  foreach (rules_get_events() as $name => $info) {
    $sets['event_'. $name] = $info;
  }
  return isset($key) ? $sets[$key] : $sets;
}

/**
 * Gathers module definitions for the given name
 * Used for collecting events, rules, actions and condtions from other modules
 *
 * @param $name The type of the data item to collect. This is also the name of the invoked hook.
 * @param $key Whether to retrieve all definitions or only the one with the given key
 * @param $alter Whether drupal_alter() should be invoked for this data
 * @param $reset If the static cache should be reseted. Note that if set to true, nothing will be
 *               returned.
 */
function rules_gather_data($name, $key = 'all', $alter = TRUE, $reset = FALSE) {
  static $data = array();

  if ($reset) {
    $data = array();
    return;
  }
  if (!isset($data[$name])) {
    $data[$name] = module_invoke_all($name);
    if ($alter) {
      drupal_alter($name, $data['name']);
    }
  }
  return $key != 'all' ? (isset($data[$name][$key]) ? $data[$name][$key] : NULL) : $data[$name];
}

/**
 * Extracts the property with the given name while keeping the keys
 * 
 * @param $key The name of the property to extract
 * @param $elements An array of elements
 * @return An array of extracted properties.
 */
function rules_extract_property($elements, $key) {
  $data = array();
  foreach ($elements as $name => $info) {
    $data[$name] = $info[$key];
  }
  return $data;
}

/**
 * Returns the rule set $set_name, which includes the set info and the rules.
 * To improve performance rule sets are cached.
 *
 * @param $set_name The name of the set which should be returned.
 * @param $reset May be set to true to clear the static $sets cache.
 * @return Returns the set only containing active rules, ready for evaluation
 */
function rules_get_rule_set($set_name, $reset = FALSE) {
  //We prevent a lot of queries by storing all sets with active rules with variable_set
  static $sets;

  if (!isset($sets) || $reset) {
    $sets = array();
    _rules_get_rule_set_initialize($sets);
  }

  if (isset($set_name) && !isset($sets[$set_name])) {
    if (!$reset && $cache = cache_get('set_'. $set_name, 'cache_rules')) {
      $sets[$set_name] = $cache->data;
    }
    else {
      //cache miss, so refresh the cache for all sets
      $sets = _rules_get_rule_sets();
      //and write the cache
      foreach ($sets as $name => $set) {
        cache_set('set_'. $name, $set, 'cache_rules');
      }
      //get all inactive sets and store them to speed up later calls
      variable_set('rules_inactive_sets', array_diff(array_keys(rules_get_rule_sets()), array_keys($sets)));
      _rules_get_rule_set_initialize($sets);
    }
  }
  return isset($set_name) && isset($sets[$set_name]) ? $sets[$set_name] : array();
}

/**
 * Initializes inactive sets
 */
function _rules_get_rule_set_initialize(&$sets) {
  foreach (variable_get('rules_inactive_sets', array()) as $name) {
    $sets[$name] = array();
  }
}

/**
 * Actually retrieves all active rules bypassing the cache
 */
function _rules_get_rule_sets() {
  $sets = array();
  $rules = array_filter(rules_get_configuration('rules'), '_rules_rule_is_active');
  foreach ($rules as $name => $rule) {
    $sets += array($rule['#set'] => array());
    $sets[ $rule['#set'] ]['info'] = rules_get_rule_sets($rule['#set']);
    $sets[ $rule['#set'] ]['rules'][$name] = $rule;
  }
  return $sets;
}

/**
 * Helper for array_filter()
 */
function _rules_rule_is_active($rule) {
  _rules_element_defaults($rule);
  return $rule['#active'];
}

/**
 * Clears the rule set cache
 * @param $immediate If FALSE, the static cache will be kept until the next page load.
 *    Might be dangerous, so only use if you know what you are doing.
 */
function rules_clear_cache($immediate = TRUE) {
  cache_clear_all('set_', 'cache_rules', TRUE);
  variable_del('rules_inactive_sets');
  if ($immediate) {
    rules_get_rule_set(NULL, TRUE);
    rules_gather_data('', 'all', FALSE, TRUE);
  }
}

/**
 * Implementation of hook_flush_caches
 */
function rules_flush_caches() {
  variable_del('rules_inactive_sets');
  return array('cache_rules');
}

/**
 * Invokes configured rules for the given event
 * @param $event_name The events name
 * @params $args Pass further arguments as defined in hook_event_info() for this event.
 */
function rules_invoke_event() {
  $args = func_get_args();
  $args[0] = 'event_'. $args[0];
  call_user_func_array('rules_invoke_rule_set', $args);
}

/**
 * Invokes configured rules for the given rule set
 * @param $set_name The name of the rule set to invoke
 * @params $args Further arguments as defined for the rule set
 */
function rules_invoke_rule_set() {
  $args = func_get_args();
  $set_name = array_shift($args);

  if ($set = rules_get_rule_set($set_name)) {
    $state = array('set_info' => $set['info']);

    _rules_log_set_invocation(t('%label has been invoked.', array('%label' => $state['set_info']['label'])), TRUE);

    _rules_initialize_arguments($state, $args);
    rules_evaluate_elements($set['rules'], $state);

    //save all changed arguments..
    foreach ($state['arguments'] as &$argument) {
      $argument->save_changes();
    }

    _rules_log_set_invocation(t('Evaluation of %label has been finished.', array('%label' => $state['set_info']['label'])), FALSE);

    //only show the log, if this is no nested evaluation
    if (rules_log_evaluation_finished()) {
      rules_show_log();
    }
  }
}

/**
 * Evaluates the elements in a recursive way
 * The elements are a tree of rules, conditions, actions and logical operations (AND, OR,..)
 *
 * Each element is executed by using rules_execute_element().
 *
 * Elements can use '#execute' to set their execution handler, which can be used to
 * to customize the evaluation of the children. E.g. the element 'OR' does this and
 * evaluates to TRUE if at least one of its children evaluate to TRUE.
 *
 * @param $elements An array of elements to evaluate
 * @param $state The current evaluation state
 */
function rules_evaluate_elements($elements, &$state) {
  $result = FALSE;

  //Execute the current element if not yet executed
  if (!isset($elements['#_executed'])) {
    $elements['#_executed'] = TRUE;
    $result = rules_execute_element($elements, $state);
  }

  // we default to evaluate like an AND, which means we stop as soon as one element evaluates to FALSE
  // so if the element hasn't evaluated the children, start now
  if ((!isset($elements['#_evaluated']) || $elements['#_evaluated'] == FALSE)) {
    $elements['#_evaluated'] = TRUE;
    $result = rules_execute_and($elements, $state);
  }
  return $result;
}

/**
 * Sorts the children of the elements
 */
function _rules_sort_children(&$element) {
  if (!isset($element['#_sorted'])) {
    $element['#_sorted'] = TRUE;
    uasort($element, "_rules_element_sort");
  }
}

/**
 * Callback function for uasort()
 */
function _rules_element_sort($a, $b) {
  if (!is_array($a) || !is_array($b)) {
    return !is_array($a) ? -1 : 1; //element properties go up
  }
  $a += array('#type' => '', '#weight' => 0, '#id' => 1000);
  $b += array('#type' => '', '#weight' => 0, '#id' => 1000);
  if (($b['#type'] == 'action' && $a['#type'] != 'action')) {
    return -1; //actions sink always down
  }
  if (($a['#type'] == 'action' && $b['#type'] != 'action')) {
    return 1; //actions sink always down
  }
  if ($a['#weight'] == $b['#weight']) {
    return ($a['#id'] < $b['#id']) ? -1 : 1;
  }
  return ($a['#weight'] < $b['#weight']) ? -1 : 1;
}

/**
 * Makes sure the element defaults are applied
 */
function _rules_element_defaults(&$element) {
  if (!isset($element['#_defaults_applied'])) {
    if ((!empty($element['#type'])) && ($info = _element_info($element['#type']))) {
      // Overlay $info onto $element, retaining preexisting keys in $element.
      $element += $info;
    }
    $element['#_defaults_applied'] = TRUE;
  }
}

/**
 * Executes the element by invoking the element type's execution handler
 *
 * @param $elements An array of elements to process
 * @param $state The current evaluation state
 * @return The execution result, or FALSE if there is no valid execution handler.
 */
function rules_execute_element(&$element, &$state) {
  if (isset($element['#type']) && isset($element['#execute']) && function_exists($element['#execute'])) {
    $element['#_evaluated'] = TRUE;
    $result = $element['#execute']($element, $state);
    return isset($element['#negate']) && $element['#negate'] == TRUE ? !$result : $result;
  }
  return FALSE;
}

/**
 * Execution handler for rules
 */
function rules_execute_rule(&$element, &$state) {
  if ($element['#active'] && !$element['#recursion'] && rules_log_rule_is_evaluated($element['#name'])) {
    rules_log(t('Not executing the rule %name on rule set %set to prevent recursion.', array('%name' => $element['#label'], '%set' => $state['set_info']['label'])));
  }
  else if ($element['#active']) {
    //remember that we are processing this rule to prevent recursion
    rules_log_evaluated_rule($element['#name'], TRUE);
    rules_log(t('Executing the rule %name on rule set %set', array('%name' => $element['#label'], '%set' => $state['set_info']['label'])));

    //let the the default evaluation (AND) apply to the rule
    rules_execute_and($element, $state);
    rules_log_evaluated_rule($element['#name'], FALSE);
  }
  //return true, so that the next rules are evaluated too
  return TRUE;
}

/**
 * Execution handler for the OR element
 * Evaluates to TRUE if at least one children evaluate to TRUE..
 */
function rules_execute_or(&$elements, &$state) {
  //first sort the children then process them
  _rules_sort_children($elements);

  foreach (element_children($elements) as $key) {
    _rules_element_defaults($elements[$key]);

    $result = rules_evaluate_elements($elements[$key], $state);
    if ($result) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Execution handler for the AND element
 * Evaluates to TRUE if all children evaluate to TRUE..
 */
function rules_execute_and(&$elements, &$state) {
  //first sort the children then process them
  _rules_sort_children($elements);

  foreach (element_children($elements) as $key) {
    _rules_element_defaults($elements[$key]);

    $result = rules_evaluate_elements($elements[$key], $state);
    if ($result === FALSE) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Execution handler for actions
 *
 * @param $element The action's configuration element
 * @param $state The current evaluation state
 * @return TRUE to let rules proceed wit executing actions, only FALSE if $result['#halt'] is set.
 */
function rules_execute_action($element, &$state) {
  if (isset($element['#name']) && function_exists($element['#name'])) {

    $exec_args = rules_get_execution_arguments($element, $state);
    if ($exec_args !== FALSE) {
      $result = call_user_func_array($element['#name'], $exec_args);

      //Add newly added arguments by the action
      if (isset($result['#new arguments']) && $result['#new arguments']) {
        rules_add_new_arguments($element, $result['#new arguments'], $state);
      }
      //An action may return altered arguments, which are saved automatically
      if (isset($result) && is_array($result)) {
        $reverse_map = array_flip($element['#argument map']);

        foreach (element_children($result) as $argument_name) {
          if (isset($reverse_map[$argument_name])) {
            $argument = &$state['arguments'][ $reverse_map[$argument_name] ];
            $argument->update( $result[$argument_name] );
            $argument->save();            
          }
        }
      }
      rules_log(t('Action execution: @name', array('@name' => rules_get_element_label($element, $state))));
    }
    return TRUE;
  }
  rules_error_missing_implementation($element);
}

/**
 * Execution handler for conditions
 * Note: An condition may not alter arguments
 *
 * @param $element The condition's configuration element
 * @param $state The current evaluation state
 * @return The execution result of the condition, or if it is no valid condition FALSE.
 */
function rules_execute_condition($element, &$state) {
  if (isset($element['#name']) && function_exists($element['#name'])) {

    $exec_args = rules_get_execution_arguments($element, $state);
    if ($exec_args !== FALSE) {
      $result = call_user_func_array($element['#name'], $exec_args);

      rules_log(t('Condition %name evaluated to @bool.', array('%name' => rules_get_element_label($element, $state), '@bool' => $result ? 'TRUE' : 'FALSE')));
      return $result;
    }
    return FALSE;
  }
  rules_error_missing_implementation($element);
  return FALSE;
}

/**
 * Writes the message into the log
 */
function rules_log($message, $error = FALSE) {
  global $_rules_log;

  list($usec, $sec) = explode(" ", microtime());
  $_rules_log[] = array('time' => array('sec' => $sec, 'usec' => $usec), 'msg' => $message, 'error' => $error);
}

/**
 * Writes to the log and marks the entry to be the first one of a just started set
 */
function _rules_log_set_invocation($message, $start = TRUE) {
  global $_rules_log;
  
  if (!isset($_rules_log)) {
    $_rules_log = array();
  }

  list($usec, $sec) = explode(" ", microtime());
  $_rules_log[] = array('time' => array('sec' => $sec, 'usec' => $usec), 'msg' => $message, 'error' => FALSE, 'start' => $start);  
}


/**
 * Implementation of hook_elements()
 * Defines default values for all available properties of rules's element types
 *
 * Note that the #process handlers are only used by the form API, but not by the rules engine.
 */
function rules_elements() {
  $types = array();
  $types['rule'] = array('#name' => '', '#set' => '', '#recursion' => FALSE, '#fixed' => FALSE, '#active' => TRUE, '#altered' => FALSE, '#execute' => 'rules_execute_rule', '#process' => array('rules_ui_prepare_configuration' => array()));
  $types['condition'] = array('#name' => '', '#info' => TRUE, '#argument map' => array(), '#negate' => FALSE, '#settings' => array(), '#execute' => 'rules_execute_condition', '#suffix' => '<br clear="all" />');
  $types['action'] = array('#name' => '', '#info' => TRUE, '#argument map' => array(), '#settings' => array(), '#execute' => 'rules_execute_action', '#suffix' => '<br clear="all" />');
  $types['OR'] = array('#execute' => 'rules_execute_or', '#logical_op' => TRUE, '#negate' => FALSE, '#theme' => 'rules_operation', '#label' => t('OR'));
  $types['AND'] = array('#execute' => 'rules_execute_and', '#logical_op' => TRUE, '#negate' => FALSE, '#theme' => 'rules_operation', '#label' => t('AND'));
  return $types;
}

/**
 * Gets the element info of an element (actions, conditions,..)
 * Note that the element defaults will be applied before, if not yet done.
 */
function rules_get_element_info(&$element) {
  _rules_element_defaults($element);
  if ($element['#info'] && $element['#name']) {
    if ($info = rules_gather_data('rules_'. $element['#type']. '_info', $element['#name'])) {
      return $info + array('arguments' => array(), 'fixed' => FALSE);
    }
    rules_error_missing_implementation($element);
  }
  return array();
}

/**
 * Gets the element's label
 */
function rules_get_element_label($element, &$state) {
  if (!isset($element['#label'])) {
    $info = rules_get_element_info($element);
    return $info['label'];
  }
  return $element['#label'];
}

/**
 * A simple helping function, which eases the creation of configurations
 * Example use case:  $configuration['or'] = rules_configure('OR', $condition1, conditions2);
 *
 * @param $op One supported operation like 'AND', 'OR'. If ommitted the passed elements
 *   will just be added to the first one.
 * @param $elements The elements to configure.
 */
function rules_configure() {
  $args = func_get_args();
  $op = array_shift($args);

  if (!is_string($op) && is_array($op)) {
    //just add the elements to the first element
    return array_merge($op, $args);
  }
  $op = strtoupper($op);

  $element = rules_use_element($op);
  $element += $args;
  return $element;
}

/**
 * Configures a condition for using in a configuration
 *
 * @param $name The name of condition to create, as specified at hook_condition_info()
 * @param $params An optional array of properties to add, e.g. #argument_map
 */
function rules_use_condition($name, $params = array()) {
  $params += array('#name' => $name);
  return rules_use_element('condition', $params);
}

/**
 * Configures an action for using in a configuration
 *
 * @param $name The name of action to create, as specified at hook_action_info()
 * @param $params An optional array of properties to add, e.g. #argument_map
 */
function rules_use_action($name, $params = array()) {
  $params += array('#name' => $name);
  return rules_use_element('action', $params);
}

/**
 * Configures an element of type $type with the further properties $params for using in a configuration
 */
function rules_use_element($type, $params = array()) {
  $element = array('#type' => $type);
  $element += $params;
  return $element;
}

/**
 * Shows the log and clears it afterwards
 */
function rules_show_log() {
  global $_rules_log;

  if (is_array($_rules_log) && count($_rules_log)) {
    $i = 0;
    $error = FALSE;
    $msg = _rules_show_log($i, $_rules_log, $error);
    $_rules_log = NULL;

    if ($error) {
      rules_handle_error_msg(t('An error occured during rule evaluation. This is the evaluation log:') .' '. $msg, NULL);
    }
    else {
      drupal_set_message($msg);
    }
  }
}

function _rules_show_log(&$i, $data, &$error) {
  $start = &$data[0]['time'];
  $output = array();
  while ($i < count($data)) {
    
    $diff = ($data[$i]['time']['sec'] - $start['sec'])*1000000 + $data[$i]['time']['usec'] - $start['usec'];
    $formatted_diff = round($diff * 1000, 3). ' ms';
    $msg = $formatted_diff . ' '. $data[$i]['msg'];

    if ($data[$i]['error']) {
      $error = TRUE;
      $msg = '<strong>'. $msg .'</strong>';
    }

    $output[] = $msg;

    if (isset($data[$i]['start']) && !$data[$i]['start']) {
      //this was the last log entry of this set
      $i++;
      return theme('item_list', $output);
    }
    $i++;
    if (isset($data[$i]['start']) && $data[$i]['start']) {
      //the next entry stems from another evaluated set, add in its log messages here
      $output[] = _rules_show_log($i, $data, $error);
    }
  }
  return theme('item_list', $output);
}

/**
 * Remembers the currently evaluated rules. With this information, recursion is prevented
 *
 * @param $name The name of the rule, which execution should be logged
 * @param $start Whether evaluation just started or finished
 */
function rules_log_evaluated_rule($name, $start) {
  global $_rules_exec_log;

  if (!isset($_rules_exec_log)) {
    $_rules_exec_log = array();
  }
  if ($start) {
    $_rules_exec_log[$name] = $name;
  }
  else {
    unset($_rules_exec_log[$name]);
  }
}

/**
 * Checks whether the given rule is currently evaluated.
 *
 * @param $name The name of the rule, which execution should be logged
 */
function rules_log_rule_is_evaluated($name) {
  global $_rules_exec_log;

  return is_array($_rules_exec_log) && in_array($name, $_rules_exec_log);
}

/**
 * Checks whether every rule evaluation is finished
 */
function rules_log_evaluation_finished() {
  global $_rules_exec_log;

  return !is_array($_rules_exec_log) || count($_rules_exec_log) == 0;
}


/**
 * Gets all configured items, regardless if defined by the admin
 * or by a module
 * 
 * @param $items Which items to get, e.g. 'rules' or 'rule_sets'
 * @return An array of configured items, where structure of the item configuration
 *   depends on the item
 */
function rules_get_configuration($items = 'rules') {
  $configurations = array();
  $info = rules_get_items($items);
  $result = db_query("SELECT * FROM {". $info['db_table']. "}");

  while ($row = db_fetch_object($result)) {
    $configurations[$row->name] = unserialize($row->data);
  }
  $configurations += rules_get_item_defaults($items);
  return $configurations;
}

/**
 * Used to inform the rules engine about added items,
 * so it can create the db table if necessary
 */
function rules_enable_items($items) {
  $info = rules_get_items($items);

  if (!db_table_exists($info['db_table'])) {
    $schema = drupal_get_schema($info['db_table'], TRUE);
    $ret = array();
    db_create_table($ret, $info['db_table'], $schema);
  }
}

/**
 * Implementation of hook_rules_item_info
 */
function rules_rules_item_info() {
  return array(
    'rules' => array(
      'label' => t('Rules'),
      'db_table' => 'rules_rules',
    ),
    'rule_sets' => array(
      'label' => t('Rule Sets'),
      'db_table' => 'rule_sets',
    ),
  );
}

/**
 * Shows an error message, that a module is missing.
 *
 * @param $element The element, for which the implementation is missing
 */
function rules_error_missing_implementation($element) {
  if (isset($element['#label']) && $element['#label']) {
    $msg = t('Unable to find %type of name %name with the label %label. Perhaps the according module has been deactivated.', array('%type' => $element['#type'], '%name' => $element['#name'], '%label' => $element['#label']));
  }
  else {
    $msg = t('Unable to find %type of name %name. Perhaps the according module has been deactivated.', array('%type' => $element['#type'], '%name' => $element['#name']));
  }
  rules_log($msg, TRUE);
}

/**
 * Handles a error message. If the user has permission to administer the rules engine,
 * show him the error. Otherwise just log it.
 */
function rules_handle_error_msg($message, $variables, $rule_name = NULL) {
  if (user_access('administer rules')) {
    drupal_set_message(t($message, $variables), 'error');
  }
  $link = (isset($rule_name)) ? l(t('Show rule configuration'), PATH .'/'. $rule_name) : NULL;
  watchdog('rules', $message, $variables, WATCHDOG_ERROR, $link);
}

/**
 * Determines if the given entity type is supported by the given info
 * 
 * @param $entity_type The entity type to check
 * @param $info The information data containing the #entity property
 */
function rules_is_valid_entity($entity_type, $info) {
  if (is_array($info['entity'])) {
    return in_array($entity_type, $info['entity']);
  }
  if ($info['entity'] == '*') {
    return TRUE;
  }
  return $info['entity'] == $entity_type;
}

/**
 * Implementation of hook_entity_info
 */
function rules_entity_info() {
  return array(
    'node' => array('#save' => 'rules_node_save'),
    'comment' => array('#save' => 'rules_comment_save')
  );
}

/**
 * Wrappers around drupal's saving functions
 */
function rules_node_save($node) {
  //make sure to not create a new revision when workflow-ng saves a node
  $node->revision = FALSE;
  node_save($node);
}

/**
 * Wrappers around drupal's saving functions
 */
function rules_comment_save($comment) {
  comment_save((array)$comment);
}

/**
 * Own version of array_intersect_key for php < 5.1
 */
if (!function_exists('array_intersect_key')) {
    function array_intersect_key()
    {
        $arrs = func_get_args();
        $result = array_shift($arrs);
        foreach ($arrs as $array) {
            foreach ($result as $key => $v) {
                if (!array_key_exists($key, $array)) {
                    unset($result[$key]);
                }
            }
        }
        return $result;
   }
}

/**
 * Implementation of hook_form_alter()
 * Clear the cache when a module is deactivated
 */
function rules_form_alter($form_id, $form) {
  if ($form_id == 'system_modules') {
    rules_clear_cache();
  }
}

/**
 * Include default configuration files
 */
function _rules_include_rules_defaults() {
  static $included;

  if (!isset($included)) {
    foreach (module_list() as $module) {
	    $module_path = drupal_get_path('module', $module);
	    if (file_exists("$module_path/$module.rules_defaults.inc")) {
	      require_once "./$module_path/$module.rules_defaults.inc";
	    }
	  }
    $included = TRUE;
  }
}
